<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Sep 10 11:26:48 PDT 2004 -->
<TITLE>
Cipher (GNU cryptographic primitives and tools)
</TITLE>
<META NAME="keywords" CONTENT="javax.crypto.Cipher,Cipher class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Cipher (GNU cryptographic primitives and tools)";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<A HREF="#main"><FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../serialized-form.html"><FONT CLASS="NavBarFont1"><B>Serialized</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
For the latest news and information visit<BR><A HREF="http://www.gnu.org/software/gnu-crypto">The GNU Crypto project</A></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../javax/crypto/CipherInputStream.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Cipher.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<A NAME="main"></A>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.crypto</FONT>
<BR>
Class Cipher</H2>
<PRE>
java.lang.Object
  |
  +--<B>javax.crypto.Cipher</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../javax/crypto/NullCipher.html">NullCipher</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>Cipher</B><DT>extends java.lang.Object</DL>

<P>
This class provides the functionality of a cryptographic cipher for
 encryption and decryption. It forms the core of the Java Cryptographic
 Extension (JCE) framework.
 <p>
 In order to create a Cipher object, the application calls the
 Cipher's <code>getInstance</code> method, and passes the name of the
 requested <i>transformation</i> to it. Optionally, the name of a provider
 may be specified.
 <p>
 A <i>transformation</i> is a string that describes the operation (or
 set of operations) to be performed on the given input, to produce some
 output. A transformation always includes the name of a cryptographic
 algorithm (e.g., <i>DES</i>), and may be followed by a feedback mode and
 padding scheme.

 <p> A transformation is of the form:<p>

 <ul>
 <li>"<i>algorithm/mode/padding</i>" or
 <p>
 <li>"<i>algorithm</i>"
 </ul>

 <P> (in the latter case,
 provider-specific default values for the mode and padding scheme are used).
 For example, the following is a valid transformation:<p>

 <pre>
     Cipher c = Cipher.getInstance("<i>DES/CBC/PKCS5Padding</i>");
 </pre>
 <p>
 When requesting a block cipher in stream cipher mode (e.g.,
 <code>DES</code> in <code>CFB</code> or <code>OFB</code> mode), the user may
 optionally specify the number of bits to be
 processed at a time, by appending this number to the mode name as shown in
 the "<i>DES/CFB8/NoPadding</i>" and "<i>DES/OFB32/PKCS5Padding</i>"
 transformations. If no such number is specified, a provider-specific default
 is used. (For example, the "SunJCE" provider uses a default of 64 bits.)
<P>

<P>
<DL>
<DT><B>Since: </B></DT>
  <DD>1.4</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#DECRYPT_MODE">DECRYPT_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#ENCRYPT_MODE">ENCRYPT_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#PRIVATE_KEY">PRIVATE_KEY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#PUBLIC_KEY">PUBLIC_KEY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#SECRET_KEY">SECRET_KEY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#UNWRAP_MODE">UNWRAP_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#WRAP_MODE">WRAP_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#Cipher(javax.crypto.CipherSpi, java.security.Provider, java.lang.String)">Cipher</A></B>(<A HREF="../../javax/crypto/CipherSpi.html">CipherSpi</A>&nbsp;cipherSpi,
       java.security.Provider&nbsp;provider,
       java.lang.String&nbsp;transformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a Cipher object.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal()">doFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finishes a multiple-part encryption or decryption operation, depending
 on how this cipher was initialized.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[])">doFinal</A></B>(byte[]&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int)">doFinal</A></B>(byte[]&nbsp;output,
        int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finishes a multiple-part encryption or decryption operation, depending
 on how this cipher was initialized.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int, int)">doFinal</A></B>(byte[]&nbsp;input,
        int&nbsp;inputOffset,
        int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int, int, byte[])">doFinal</A></B>(byte[]&nbsp;input,
        int&nbsp;inputOffset,
        int&nbsp;inputLen,
        byte[]&nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int, int, byte[], int)">doFinal</A></B>(byte[]&nbsp;input,
        int&nbsp;inputOffset,
        int&nbsp;inputLen,
        byte[]&nbsp;output,
        int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getAlgorithm()">getAlgorithm</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the algorithm name of this <code>Cipher</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getBlockSize()">getBlockSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the block size (in bytes).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/crypto/ExemptionMechanism.html">ExemptionMechanism</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getExemptionMechanism()">getExemptionMechanism</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the exemption mechanism object used with this cipher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/crypto/Cipher.html">Cipher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getInstance(java.lang.String)">getInstance</A></B>(java.lang.String&nbsp;transformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generates a <code>Cipher</code> object that implements the specified
 transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/crypto/Cipher.html">Cipher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getInstance(java.lang.String, java.security.Provider)">getInstance</A></B>(java.lang.String&nbsp;transformation,
            java.security.Provider&nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Cipher</code> object that implements the specified
 transformation, as supplied by the specified provider.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/crypto/Cipher.html">Cipher</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getInstance(java.lang.String, java.lang.String)">getInstance</A></B>(java.lang.String&nbsp;transformation,
            java.lang.String&nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Cipher</code> object that implements the specified
 transformation, as supplied by the specified provider.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getIV()">getIV</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the initialization vector (IV) in a new buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)">getOutputSize</A></B>(int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the length in bytes that an output buffer would need to be in
 order to hold the result of the next <code>update</code> or
 <code>doFinal</code> operation, given the input length <code>inputLen</code> (in bytes).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.security.AlgorithmParameters</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getParameters()">getParameters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the parameters used with this cipher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.security.Provider</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getProvider()">getProvider</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the provider of this <code>Cipher</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.cert.Certificate)">init</A></B>(int&nbsp;opmode,
     java.security.cert.Certificate&nbsp;certificate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with the public key from the given certificate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.cert.Certificate, java.security.SecureRandom)">init</A></B>(int&nbsp;opmode,
     java.security.cert.Certificate&nbsp;certificate,
     java.security.SecureRandom&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with the public key from the given certificate
 and a source of randomness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key)">init</A></B>(int&nbsp;opmode,
     java.security.Key&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.AlgorithmParameters)">init</A></B>(int&nbsp;opmode,
     java.security.Key&nbsp;key,
     java.security.AlgorithmParameters&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key and a set of algorithm
 parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec)">init</A></B>(int&nbsp;opmode,
     java.security.Key&nbsp;key,
     java.security.spec.AlgorithmParameterSpec&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key and a set of algorithm parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)">init</A></B>(int&nbsp;opmode,
     java.security.Key&nbsp;key,
     java.security.spec.AlgorithmParameterSpec&nbsp;params,
     java.security.SecureRandom&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key, a set of algorithm
 parameters, and a source of randomness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)">init</A></B>(int&nbsp;opmode,
     java.security.Key&nbsp;key,
     java.security.AlgorithmParameters&nbsp;params,
     java.security.SecureRandom&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key, a set of algorithm
 parameters, and a source of randomness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.SecureRandom)">init</A></B>(int&nbsp;opmode,
     java.security.Key&nbsp;key,
     java.security.SecureRandom&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key and a source of randomness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.security.Key</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#unwrap(byte[], java.lang.String, int)">unwrap</A></B>(byte[]&nbsp;wrappedKey,
       java.lang.String&nbsp;wrappedKeyAlgorithm,
       int&nbsp;wrappedKeyType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unwrap a previously wrapped key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[])">update</A></B>(byte[]&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[], int, int)">update</A></B>(byte[]&nbsp;input,
       int&nbsp;inputOffset,
       int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[], int, int, byte[])">update</A></B>(byte[]&nbsp;input,
       int&nbsp;inputOffset,
       int&nbsp;inputLen,
       byte[]&nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[], int, int, byte[], int)">update</A></B>(byte[]&nbsp;input,
       int&nbsp;inputOffset,
       int&nbsp;inputLen,
       byte[]&nbsp;output,
       int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#wrap(java.security.Key)">wrap</A></B>(java.security.Key&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrap a key.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ENCRYPT_MODE"><!-- --></A><H3>
ENCRYPT_MODE</H3>
<PRE>
public static final int <B>ENCRYPT_MODE</B></PRE>
<DL>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.ENCRYPT_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DECRYPT_MODE"><!-- --></A><H3>
DECRYPT_MODE</H3>
<PRE>
public static final int <B>DECRYPT_MODE</B></PRE>
<DL>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.DECRYPT_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="WRAP_MODE"><!-- --></A><H3>
WRAP_MODE</H3>
<PRE>
public static final int <B>WRAP_MODE</B></PRE>
<DL>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.WRAP_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="UNWRAP_MODE"><!-- --></A><H3>
UNWRAP_MODE</H3>
<PRE>
public static final int <B>UNWRAP_MODE</B></PRE>
<DL>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.UNWRAP_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PUBLIC_KEY"><!-- --></A><H3>
PUBLIC_KEY</H3>
<PRE>
public static final int <B>PUBLIC_KEY</B></PRE>
<DL>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.PUBLIC_KEY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PRIVATE_KEY"><!-- --></A><H3>
PRIVATE_KEY</H3>
<PRE>
public static final int <B>PRIVATE_KEY</B></PRE>
<DL>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.PRIVATE_KEY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SECRET_KEY"><!-- --></A><H3>
SECRET_KEY</H3>
<PRE>
public static final int <B>SECRET_KEY</B></PRE>
<DL>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.SECRET_KEY">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Cipher(javax.crypto.CipherSpi, java.security.Provider, java.lang.String)"><!-- --></A><H3>
Cipher</H3>
<PRE>
protected <B>Cipher</B>(<A HREF="../../javax/crypto/CipherSpi.html">CipherSpi</A>&nbsp;cipherSpi,
                 java.security.Provider&nbsp;provider,
                 java.lang.String&nbsp;transformation)</PRE>
<DL>
<DD>Creates a Cipher object.
<P>
<DT><B>Parameters:</B><DD><CODE>cipherSpi</CODE> - the delegate<DD><CODE>provider</CODE> - the provider<DD><CODE>transformation</CODE> - the transformation</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getInstance(java.lang.String)"><!-- --></A><H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../javax/crypto/Cipher.html">Cipher</A> <B>getInstance</B>(java.lang.String&nbsp;transformation)
                                throws java.security.NoSuchAlgorithmException,
                                       <A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></PRE>
<DL>
<DD>Generates a <code>Cipher</code> object that implements the specified
 transformation.
 <p>
 If the default provider package supplies an implementation of the
 requested transformation, an instance of <code>Cipher</code> containing
 that implementation is returned.
 If the transformation is not available in the default provider package,
 other provider packages are searched.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>transformation</CODE> - the name of the transformation, e.g., <i>DES/CBC/PKCS5Padding</i>.
 See Appendix A in the Java Cryptography Extension API Specification &amp; Reference
 for information about standard transformation names.
<DT><B>Returns:</B><DD>a cipher that implements the requested transformation
<DT><B>Throws:</B>
<DD><CODE>java.security.NoSuchAlgorithmException</CODE> - if the specified transformation is not available in the default
 provider package or any of the other provider packages that were searched.
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></CODE> - if <code>transformation</code> contains a padding scheme that is
 not available.</DL>
</DD>
</DL>
<HR>

<A NAME="getInstance(java.lang.String, java.security.Provider)"><!-- --></A><H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../javax/crypto/Cipher.html">Cipher</A> <B>getInstance</B>(java.lang.String&nbsp;transformation,
                                       java.security.Provider&nbsp;provider)
                                throws java.security.NoSuchAlgorithmException,
                                       <A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></PRE>
<DL>
<DD>Creates a <code>Cipher</code> object that implements the specified
 transformation, as supplied by the specified provider. Note: the
 <code>provider</code> doesn't have to be registered.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>transformation</CODE> - the name of the transformation, e.g.,
 <i>DES/CBC/PKCS5Padding</i>. See Appendix A in the Java Cryptography
 Extension Reference Guide for information about standard transformation
 names.<DD><CODE>provider</CODE> - the provider
<DT><B>Returns:</B><DD>a cipher that implements the requested transformation
<DT><B>Throws:</B>
<DD><CODE>java.security.NoSuchAlgorithmException</CODE> - if no transformation was specified, or
 if the specified transformation is not available from the specified
 provider.
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></CODE> - if transformation contains a padding
 scheme that is not available.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the provider is null.</DL>
</DD>
</DL>
<HR>

<A NAME="getInstance(java.lang.String, java.lang.String)"><!-- --></A><H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../javax/crypto/Cipher.html">Cipher</A> <B>getInstance</B>(java.lang.String&nbsp;transformation,
                                       java.lang.String&nbsp;provider)
                                throws java.security.NoSuchAlgorithmException,
                                       java.security.NoSuchProviderException,
                                       <A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></PRE>
<DL>
<DD>Creates a <code>Cipher</code> object that implements the specified
 transformation, as supplied by the specified provider.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>transformation</CODE> - the name of the transformation, e.g., <i>DES/CBC/PKCS5Padding</i>.
 See Appendix A in the Java Cryptography Extension API Specification &amp; Reference
 for information about standard transformation names.<DD><CODE>provider</CODE> - the name of the provider
<DT><B>Returns:</B><DD>a cipher that implements the requested transformation
<DT><B>Throws:</B>
<DD><CODE>java.security.NoSuchAlgorithmException</CODE> - if no transformation was specified, or if the specified
 transformation is not available from the specified provider.
<DD><CODE>java.security.NoSuchProviderException</CODE> - if the specified provider has not been configured.
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></CODE> - if <code>transformation</code> contains a padding scheme
 that is not available.</DL>
</DD>
</DL>
<HR>

<A NAME="getProvider()"><!-- --></A><H3>
getProvider</H3>
<PRE>
public final java.security.Provider <B>getProvider</B>()</PRE>
<DL>
<DD>Returns the provider of this <code>Cipher</code> object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the provider of this <code>Cipher</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="getAlgorithm()"><!-- --></A><H3>
getAlgorithm</H3>
<PRE>
public final java.lang.String <B>getAlgorithm</B>()</PRE>
<DL>
<DD>Returns the algorithm name of this <code>Cipher</code> object.
 <p>
 This is the same name that was specified in one of the
 <code>getInstance</code> calls that created this <code>Cipher</code>
 object..
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the algorithm name of this <code>Cipher</code> object.</DL>
</DD>
</DL>
<HR>

<A NAME="getBlockSize()"><!-- --></A><H3>
getBlockSize</H3>
<PRE>
public final int <B>getBlockSize</B>()</PRE>
<DL>
<DD>Returns the block size (in bytes).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the block size (in bytes), or 0 if the underlying algorithm is not a block cipher</DL>
</DD>
</DL>
<HR>

<A NAME="getOutputSize(int)"><!-- --></A><H3>
getOutputSize</H3>
<PRE>
public final int <B>getOutputSize</B>(int&nbsp;inputLen)
                        throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Returns the length in bytes that an output buffer would need to be in
 order to hold the result of the next <code>update</code> or
 <code>doFinal</code> operation, given the input length <code>inputLen</code> (in bytes).
 <p>
 This call takes into account any unprocessed (buffered) data from a
 previous <code>update</code> call, and padding.
 <p>
 The actual output length of the next <code>update</code> or
 <code>doFinal</code> call may be smaller than the length returned by
 this method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inputLen</CODE> - the input length (in bytes)
<DT><B>Returns:</B><DD>the required output buffer size (in bytes)
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state (e.g., has not
 yet been initialized)</DL>
</DD>
</DL>
<HR>

<A NAME="getIV()"><!-- --></A><H3>
getIV</H3>
<PRE>
public final byte[] <B>getIV</B>()</PRE>
<DL>
<DD>Returns the initialization vector (IV) in a new buffer.
 <p>
 This is useful in the case where a random IV was created,
 or in the context of password-based encryption or decryption, where the IV
 is derived from a user-supplied password.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the initialization vector in a new buffer, or null if the
 underlying algorithm does not use an IV, or if the IV has not yet been set.</DL>
</DD>
</DL>
<HR>

<A NAME="getParameters()"><!-- --></A><H3>
getParameters</H3>
<PRE>
public final java.security.AlgorithmParameters <B>getParameters</B>()</PRE>
<DL>
<DD>Returns the parameters used with this cipher.
 <p>
 The returned parameters may be the same that were used to initialize
 this cipher, or may contain a combination of default and random
 parameter values used by the underlying cipher implementation if this
 cipher requires algorithm parameters but was not initialized with any.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the parameters used with this cipher, or null if this cipher
 does not use any parameters.</DL>
</DD>
</DL>
<HR>

<A NAME="getExemptionMechanism()"><!-- --></A><H3>
getExemptionMechanism</H3>
<PRE>
public final <A HREF="../../javax/crypto/ExemptionMechanism.html">ExemptionMechanism</A> <B>getExemptionMechanism</B>()</PRE>
<DL>
<DD>Returns the exemption mechanism object used with this cipher.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the exemption mechanism object used with this cipher, or
 null if this cipher does not use any exemption mechanism.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.Key&nbsp;key)
                throws java.security.InvalidKeyException</PRE>
<DL>
<DD>Initializes this cipher with a key.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending
 on the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters that cannot be
 derived from the given <code>key</code>, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidKeyException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#getParameters()">getParameters</a> or
 <a href = "#getIV()">getIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the <a href="http://java.sun.com/products/jdk/1.2/docs/api/java.security.SecureRandom.html">
 <code>SecureRandom</code></a> implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the following:
 <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
 <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the key
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for
 initializing this cipher, or if this cipher is being initialized for
 decryption and requires algorithm parameters that cannot be
 determined from the given key, or if the given key has a keysize that
 exceeds the maximum allowable keysize (as determined from the
 configured jurisdiction policy files). Note: Jurisdiction files are ignored
 in this implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.SecureRandom)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.Key&nbsp;key,
                       java.security.SecureRandom&nbsp;random)
                throws java.security.InvalidKeyException</PRE>
<DL>
<DD>Initializes this cipher with a key and a source of randomness.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters that cannot be
 derived from the given <code>key</code>, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidKeyException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#engineGetParameters()">engineGetParameters</a> or
 <a href = "#engineGetIV()">engineGetIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from <code>random</code>.
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the
 following: <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
 <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>random</CODE> - the source of randomness
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for
 initializing this cipher, or if this cipher is being initialized for
 decryption and requires algorithm parameters that cannot be
 determined from the given key, or if the given key has a keysize that
 exceeds the maximum allowable keysize (as determined from the
 configured jurisdiction policy files). Note: Jurisdiction files are ignored
 in this implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.Key&nbsp;key,
                       java.security.spec.AlgorithmParameterSpec&nbsp;params)
                throws java.security.InvalidKeyException,
                       java.security.InvalidAlgorithmParameterException</PRE>
<DL>
<DD>Initializes this cipher with a key and a set of algorithm parameters.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters and
 <code>params</code> is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidAlgorithmParameterException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#getParameters()">getParameters</a> or
 <a href = "#getIV()">getIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
 <a href="http://java.sun.com/products/jdk/1.2/docs/api/java.security.SecureRandom.html">
 <code>SecureRandom</code></a> implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the
 following: <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>
 or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>params</CODE> - the algorithm parameters
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for initializing this
 cipher, or its keysize exceeds the maximum allowable keysize (as determined from the
 configured jurisdiction policy files).
<DD><CODE>java.security.InvalidAlgorithmParameterException</CODE> - if the given algorithm parameters are
 inappropriate for this cipher, or this cipher is being initialized for decryption and
 requires algorithm parameters and <code>params</code> is null, or the given algorithm
 parameters imply a cryptographic strength that would exceed the legal limits (as determined
 from the configured jurisdiction policy files). Note: Jurisdiction files are ignored
 in this implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.Key&nbsp;key,
                       java.security.spec.AlgorithmParameterSpec&nbsp;params,
                       java.security.SecureRandom&nbsp;random)
                throws java.security.InvalidKeyException,
                       java.security.InvalidAlgorithmParameterException</PRE>
<DL>
<DD>Initializes this cipher with a key, a set of algorithm
 parameters, and a source of randomness.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters and
 <code>params</code> is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidAlgorithmParameterException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#getParameters()">getParameters</a> or
 <a href = "#getIV()">getIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from <code>random</code>.
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the
 following: <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
 <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>params</CODE> - the algorithm parameters<DD><CODE>random</CODE> - the source of randomness
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
<DD><CODE>java.security.InvalidAlgorithmParameterException</CODE> - if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher is being initialized for decryption and requires
 algorithm parameters and <code>params</code> is null, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files).
 Note: Jurisdiction files are ignored in this implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.AlgorithmParameters)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.Key&nbsp;key,
                       java.security.AlgorithmParameters&nbsp;params)
                throws java.security.InvalidKeyException,
                       java.security.InvalidAlgorithmParameterException</PRE>
<DL>
<DD>Initializes this cipher with a key and a set of algorithm
 parameters.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters and
 <code>params</code> is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidAlgorithmParameterException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#getParameters()">getParameters</a> or
 <a href = "#getIV()">getIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
 <a href="http://java.sun.com/products/jdk/1.2/docs/api/java.security.SecureRandom.html">
 <code>SecureRandom</code></a> implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the
 following: <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>
 or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>params</CODE> - the algorithm parameters
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
<DD><CODE>java.security.InvalidAlgorithmParameterException</CODE> - if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher is being initialized for decryption and requires
 algorithm parameters and <code>params</code> is null, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files).
 Note: Jurisdiction files are ignored in this implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.Key&nbsp;key,
                       java.security.AlgorithmParameters&nbsp;params,
                       java.security.SecureRandom&nbsp;random)
                throws java.security.InvalidKeyException,
                       java.security.InvalidAlgorithmParameterException</PRE>
<DL>
<DD>Initializes this cipher with a key, a set of algorithm
 parameters, and a source of randomness.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters and
 <code>params</code> is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidAlgorithmParameterException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#getParameters()">getParameters</a> or
 <a href = "#getIV()">getIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from <code>random</code>.
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the
 following: <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>
 or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>params</CODE> - the algorithm parameters<DD><CODE>random</CODE> - the source of randomness
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
<DD><CODE>java.security.InvalidAlgorithmParameterException</CODE> - if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher is being initialized for decryption and requires
 algorithm parameters and <code>params</code> is null, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files).
 Note: Jurisdiction files are ignored in this implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.cert.Certificate)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.cert.Certificate&nbsp;certificate)
                throws java.security.InvalidKeyException</PRE>
<DL>
<DD>Initializes this cipher with the public key from the given certificate.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of <code>opmode</code>.
 <p>
 If the certificate is of type X.509 and has a <i>key usage</i>
 extension field marked as critical, and the value of the <i>key usage</i>
 extension field implies that the public key in
 the certificate and its corresponding private key are not
 supposed to be used for the operation represented by the value
 of <code>opmode</code>,
 an <code>InvalidKeyException</code>
 is thrown.
 <p>
 If this cipher requires any algorithm parameters that cannot be
 derived from the public key in the given certificate, the underlying
 cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or ramdom values) if it is being
 initialized for encryption or key wrapping, and raise an <code>
 InvalidKeyException</code> if it is being initialized for decryption or
 key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#getParameters()">getParameters</a> or
 <a href = "#getIV()">getIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
 <a href="http://java.sun.com/products/jdk/1.2/docs/api/java.security.SecureRandom.html">
 <code>SecureRandom</code></a>
 implementation of the highest-priority installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the
 following:
 <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
 <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)<DD><CODE>certificate</CODE> - the certificate
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the public key in the given
 certificate is inappropriate for initializing this cipher, or this
 cipher is being initialized for decryption or unwrapping keys and
 requires algorithm parameters that cannot be determined from the
 public key in the given certificate, or the keysize of the public key
 in the given certificate has a keysize that exceeds the maximum
 allowable keysize (as determined by the configured jurisdiction policy
 files).
 Note: Jurisdiction files are ignored in this implementation.</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.cert.Certificate, java.security.SecureRandom)"><!-- --></A><H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       java.security.cert.Certificate&nbsp;certificate,
                       java.security.SecureRandom&nbsp;random)
                throws java.security.InvalidKeyException</PRE>
<DL>
<DD>Initializes this cipher with the public key from the given certificate
 and a source of randomness.
 <p>The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping
 or key unwrapping, depending on
 the value of <code>opmode</code>.
 <p>
 If the certificate is of type X.509 and has a <i>key usage</i>
 extension field marked as critical, and the value of the <i>key usage</i>
 extension field implies that the public key in
 the certificate and its corresponding private key are not
 supposed to be used for the operation represented by the value of
 <code>opmode</code>,
 an <code>InvalidKeyException</code>
 is thrown.
 <p>
 If this cipher requires any algorithm parameters that cannot be
 derived from the public key in the given <code>certificate</code>,
 the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidKeyException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#engineGetParameters()">engineGetParameters</a> or
 <a href = "#engineGetIV()">engineGetIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from <code>random</code>.
 <p>
 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the
 following: <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
 <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)<DD><CODE>certificate</CODE> - the certificate<DD><CODE>random</CODE> - the source of randomness
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the public key in the given
 certificate is inappropriate for initializing this cipher, or this
 cipher is being initialized for decryption or unwrapping keys and
 requires algorithm parameters that cannot be determined from the
 public key in the given certificate, or the keysize of the public key
 in the given certificate has a keysize that exceeds the maximum
 allowable keysize (as determined by the configured jurisdiction policy
 files).</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[])"><!-- --></A><H3>
update</H3>
<PRE>
public final byte[] <B>update</B>(byte[]&nbsp;input)
                    throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.
 <p>
 The bytes in the <code>input</code> buffer are processed, and the
 result is stored in a new buffer.
 <p>
 If <code>input</code> has a length of zero, this method returns
 <code>null</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer
<DT><B>Returns:</B><DD>the new buffer with the result, or null if the underlying
 cipher is a block cipher and the input data is too short to result in a
 new block.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[], int, int)"><!-- --></A><H3>
update</H3>
<PRE>
public final byte[] <B>update</B>(byte[]&nbsp;input,
                           int&nbsp;inputOffset,
                           int&nbsp;inputLen)
                    throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, are processed,
 and the result is stored in a new buffer.
 <p>
 If <code>inputLen</code> is zero, this method returns
 <code>null</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input
 starts<DD><CODE>inputLen</CODE> - the input length
<DT><B>Returns:</B><DD>the new buffer with the result, or null if the underlying
 cipher is a block cipher and the input data is too short to result in a
 new block.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[], int, int, byte[])"><!-- --></A><H3>
update</H3>
<PRE>
public final int <B>update</B>(byte[]&nbsp;input,
                        int&nbsp;inputOffset,
                        int&nbsp;inputLen,
                        byte[]&nbsp;output)
                 throws java.lang.IllegalStateException,
                        <A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></PRE>
<DL>
<DD>Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, are processed,
 and the result is stored in the <code>output</code> buffer.
 <p>
 If the <code>output</code> buffer is too small to hold the result,
 a <code>ShortBufferException</code> is thrown. In this case, repeat this
 call with a larger output buffer. Use
 <a href = "#getOutputSize(int)">getOutputSize</a> to determine how big
 the output buffer should be.
 <p>
 If <code>inputLen</code> is zero, this method returns
 a length of zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length<DD><CODE>output</CODE> - the buffer for the result
<DT><B>Returns:</B><DD>the number of bytes stored in <code>output</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></CODE> - if the given output buffer is too small
 to hold the result</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[], int, int, byte[], int)"><!-- --></A><H3>
update</H3>
<PRE>
public final int <B>update</B>(byte[]&nbsp;input,
                        int&nbsp;inputOffset,
                        int&nbsp;inputLen,
                        byte[]&nbsp;output,
                        int&nbsp;outputOffset)
                 throws java.lang.IllegalStateException,
                        <A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></PRE>
<DL>
<DD>Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, are processed,
 and the result is stored in the <code>output</code> buffer, starting at
 <code>outputOffset</code> inclusive.
 <p>
 If the <code>output</code> buffer is too small to hold the result,
 a <code>ShortBufferException</code> is thrown. In this case, repeat this
 call with a larger output buffer. Use
 <a href = "#getOutputSize(int)">getOutputSize</a> to determine how big
 the output buffer should be.
 <p>
 If <code>inputLen</code> is zero, this method returns
 a length of zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length<DD><CODE>output</CODE> - the buffer for the result<DD><CODE>outputOffset</CODE> - the offset in <code>output</code> where the result
 is stored
<DT><B>Returns:</B><DD>the number of bytes stored in <code>output</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></CODE> - if the given output buffer is too small
 to hold the result</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal()"><!-- --></A><H3>
doFinal</H3>
<PRE>
public final byte[] <B>doFinal</B>()
                     throws java.lang.IllegalStateException,
                            <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                            <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Finishes a multiple-part encryption or decryption operation, depending
 on how this cipher was initialized.
 <p>
 Input data that may have been buffered during a previous
 <code>update</code> operation is processed, with padding (if requested)
 being applied.
 The result is stored in a new buffer.
 <p>
 A call to this method resets this cipher object to the state
 it was in when previously initialized via a call to <code>init</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>init</code>) more data.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the new buffer with the result
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int)"><!-- --></A><H3>
doFinal</H3>
<PRE>
public final int <B>doFinal</B>(byte[]&nbsp;output,
                         int&nbsp;outputOffset)
                  throws java.lang.IllegalStateException,
                         <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                         <A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A>,
                         <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Finishes a multiple-part encryption or decryption operation, depending
 on how this cipher was initialized.
 <p>
 Input data that may have been buffered during a previous
 <code>update</code> operation is processed, with padding (if requested)
 being applied.
 The result is stored in the <code>output</code> buffer, starting at
 <code>outputOffset</code> inclusive.
 <p>
 If the <code>output</code> buffer is too small to hold the result,
 a <code>ShortBufferException</code> is thrown. In this case, repeat this
 call with a larger output buffer. Use
 <a href = "#getOutputSize(int)">getOutputSize</a> to determine how big
 the output buffer should be.
 <p>
 A call to this method resets this cipher object to the state
 it was in when previously initialized via a call to <code>init</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>init</code>) more data.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>output</CODE> - the buffer for the result<DD><CODE>outputOffset</CODE> - the offset in <code>output</code> where the result
 is stored
<DT><B>Returns:</B><DD>the number of bytes stored in <code>output</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></CODE> - if the given output buffer is too small
 to hold the result
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[])"><!-- --></A><H3>
doFinal</H3>
<PRE>
public final byte[] <B>doFinal</B>(byte[]&nbsp;input)
                     throws java.lang.IllegalStateException,
                            <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                            <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.
 <p>
 The bytes in the <code>input</code> buffer, and any input bytes that
 may have been buffered during a previous <code>update</code> operation,
 are processed, with padding (if requested) being applied.
 The result is stored in a new buffer.
 <p>
 A call to this method resets this cipher object to the state
 it was in when previously initialized via a call to <code>init</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>init</code>) more data.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer
<DT><B>Returns:</B><DD>the new buffer with the result
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int, int)"><!-- --></A><H3>
doFinal</H3>
<PRE>
public final byte[] <B>doFinal</B>(byte[]&nbsp;input,
                            int&nbsp;inputOffset,
                            int&nbsp;inputLen)
                     throws java.lang.IllegalStateException,
                            <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                            <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, and any input
 bytes that may have been buffered during a previous <code>update</code>
 operation, are processed, with padding (if requested) being applied.
 The result is stored in a new buffer.
 <p>A call to this method resets this cipher object to the state
 it was in when previously initialized via a call to <code>init</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>init</code>) more data.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length
<DT><B>Returns:</B><DD>the new buffer with the result
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int, int, byte[])"><!-- --></A><H3>
doFinal</H3>
<PRE>
public final int <B>doFinal</B>(byte[]&nbsp;input,
                         int&nbsp;inputOffset,
                         int&nbsp;inputLen,
                         byte[]&nbsp;output)
                  throws java.lang.IllegalStateException,
                         <A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A>,
                         <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                         <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, and any input
 bytes that may have been buffered during a previous <code>update</code>
 operation, are processed, with padding (if requested) being applied.
 The result is stored in the <code>output</code> buffer.
 <p>
 If the <code>output</code> buffer is too small to hold the result,
 a <code>ShortBufferException</code> is thrown. In this case, repeat this
 call with a larger output buffer. Use
 <a href = "#getOutputSize(int)">getOutputSize</a> to determine how big
 the output buffer should be.
 <p>
 A call to this method resets this cipher object to the state
 it was in when previously initialized via a call to <code>init</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>init</code>) more data.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length<DD><CODE>output</CODE> - the buffer for the result
<DT><B>Returns:</B><DD>the number of bytes stored in <code>output</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></CODE> - if the given output buffer is too small
 to hold the result
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int, int, byte[], int)"><!-- --></A><H3>
doFinal</H3>
<PRE>
public final int <B>doFinal</B>(byte[]&nbsp;input,
                         int&nbsp;inputOffset,
                         int&nbsp;inputLen,
                         byte[]&nbsp;output,
                         int&nbsp;outputOffset)
                  throws java.lang.IllegalStateException,
                         <A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A>,
                         <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                         <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, and any input
 bytes that may have been buffered during a previous
 <code>update</code> operation, are processed, with padding
 (if requested) being applied.
 The result is stored in the <code>output</code> buffer, starting at
 <code>outputOffset</code> inclusive.
 <p>
 If the <code>output</code> buffer is too small to hold the result,
 a <code>ShortBufferException</code> is thrown. In this case, repeat this
 call with a larger output buffer. Use
 <a href = "#getOutputSize(int)">getOutputSize</a> to determine how big
 the output buffer should be.
 <p>
 A call to this method resets this cipher object to the state
 it was in when previously initialized via a call to <code>init</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>init</code>) more data.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length<DD><CODE>output</CODE> - the buffer for the result<DD><CODE>outputOffset</CODE> - the offset in <code>output</code> where the result is
 stored
<DT><B>Returns:</B><DD>the number of bytes stored in <code>output</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></CODE> - if the given output buffer is too small
 to hold the result
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.security.Key)"><!-- --></A><H3>
wrap</H3>
<PRE>
public final byte[] <B>wrap</B>(java.security.Key&nbsp;key)
                  throws java.lang.IllegalStateException,
                         <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                         java.security.InvalidKeyException</PRE>
<DL>
<DD>Wrap a key.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to be wrapped.
<DT><B>Returns:</B><DD>the wrapped key.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state (e.g., has not
 been initialized).
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher, no padding
 has been requested, and the length of the encoding of the key to be wrapped is not a
 multiple of the block size.
<DD><CODE><DD>java.security.InvalidKeyException</CODE> - - if it is impossible or unsafe to
 wrap the key with this cipher (e.g., a hardware protected key is being passed to a
 software-only cipher).
<DD><CODE>java.security.InvalidKeyException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(byte[], java.lang.String, int)"><!-- --></A><H3>
unwrap</H3>
<PRE>
public final java.security.Key <B>unwrap</B>(byte[]&nbsp;wrappedKey,
                                      java.lang.String&nbsp;wrappedKeyAlgorithm,
                                      int&nbsp;wrappedKeyType)
                               throws java.lang.IllegalStateException,
                                      java.security.InvalidKeyException,
                                      java.security.NoSuchAlgorithmException</PRE>
<DL>
<DD>Unwrap a previously wrapped key.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>wrappedKey</CODE> - the key to be unwrapped.<DD><CODE>wrappedKeyAlgorithm</CODE> - the algorithm associated with the wrapped key.<DD><CODE>wrappedKeyType</CODE> - the type of the wrapped key. This must be one of
 <code>SECRET_KEY</code>, <code>PRIVATE_KEY</code>, or <code>PUBLIC_KEY</code>.
<DT><B>Returns:</B><DD>the unwrapped key.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this cipher is in a wrong state
 (e.g., has not been initialized).
<DD><CODE>java.security.InvalidKeyException</CODE> - if <code>wrappedKey</code> does not
 represent a wrapped key, or if the algorithm associated with the
 wrapped key is different from <code>wrappedKeyAlgorithm</code>
 and/or its key type is different from <code>wrappedKeyType</code>.
<DD><CODE>java.security.NoSuchAlgorithmException</CODE> - - if no installed providers
 can create keys for the <code>wrappedKeyAlgorithm</code>.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<A HREF="#main"><FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../serialized-form.html"><FONT CLASS="NavBarFont1"><B>Serialized</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
For the latest news and information visit<BR><A HREF="http://www.gnu.org/software/gnu-crypto">The GNU Crypto project</A></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../javax/crypto/CipherInputStream.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Cipher.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
Copyright &copy; 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
</BODY>
</HTML>
