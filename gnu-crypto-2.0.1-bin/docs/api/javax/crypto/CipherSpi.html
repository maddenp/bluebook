<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Sep 10 11:26:55 PDT 2004 -->
<TITLE>
CipherSpi (GNU cryptographic primitives and tools)
</TITLE>
<META NAME="keywords" CONTENT="javax.crypto.CipherSpi,CipherSpi class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="CipherSpi (GNU cryptographic primitives and tools)";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<A HREF="#main"><FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../serialized-form.html"><FONT CLASS="NavBarFont1"><B>Serialized</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
For the latest news and information visit<BR><A HREF="http://www.gnu.org/software/gnu-crypto">The GNU Crypto project</A></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/crypto/CipherOutputStream.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javax/crypto/EncryptedPrivateKeyInfo.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="CipherSpi.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<A NAME="main"></A>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.crypto</FONT>
<BR>
Class CipherSpi</H2>
<PRE>
java.lang.Object
  |
  +--<B>javax.crypto.CipherSpi</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../gnu/crypto/jce/cipher/ARCFourSpi.html">ARCFourSpi</A>, gnu.crypto.jce.cipher.CipherAdapter</DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>CipherSpi</B><DT>extends java.lang.Object</DL>

<P>
This class defines the <i>Service Provider Interface</i> (<b>SPI</b>)
 for the <code>Cipher</code> class.
 All the abstract methods in this class must be implemented by each 
 cryptographic service provider who wishes to supply the implementation
 of a particular cipher algorithm.
 <p>
 In order to create an instance of <code>Cipher</code>, which
 encapsulates an instance of this <code>CipherSpi</code> class, an
 application calls one of the
 <a href = "Cipher.html#getInstance(java.lang.String)">getInstance</a>
 factory methods of the
 <a href = "Cipher.html">Cipher</a> engine class and specifies the requested
 <i>transformation</i>.
 Optionally, the application may also specify the name of a provider.
 <p>
 A <i>transformation</i> is a string that describes the operation (or
 set of operations) to be performed on the given input, to produce some
 output. A transformation always includes the name of a cryptographic
 algorithm (e.g., <i>DES</i>), and may be followed by a feedback mode and
 padding scheme.
 <p>
 A transformation is of the form:
 <p>
 <ul>
 <li>"<i>algorithm/mode/padding</i>" or
 <p>
 <li>"<i>algorithm</i>"
 </ul>
 
 <P> (in the latter case,
 provider-specific default values for the mode and padding scheme are used).
 For example, the following is a valid transformation:<p>
 
 <pre>
     Cipher c = Cipher.getInstance("<i>DES/CBC/PKCS5Padding</i>");
 </pre>

 <p>A provider may supply a separate class for each combination
 of <i>algorithm/mode/padding</i>, or may decide to provide more generic
 classes representing sub-transformations corresponding to
 <i>algorithm</i> or <i>algorithm/mode</i> or <i>algorithm//padding</i>
 (note the double slashes),
 in which case the requested mode and/or padding are set automatically by
 the <code>getInstance</code> methods of <code>Cipher</code>, which invoke
 the <a href = "#engineSetMode(java.lang.String)">engineSetMode</a> and
 <a href = "#engineSetPadding(java.lang.String)">engineSetPadding</a>
 methods of the provider's subclass of <code>CipherSpi</code>.

 <p>A <code>Cipher</code> property in a provider master class may have one of
 the following formats:

 <ul>

 <li>
 <pre>
     // provider's subclass of "CipherSpi" implements "algName" with
     // pluggable mode and padding
     <code>Cipher.</code><i>algName</i>
 </pre>
 
 <li>
 <pre>
     // provider's subclass of "CipherSpi" implements "algName" in the
     // specified "mode", with pluggable padding
     <code>Cipher.</code><i>algName/mode</i>
 </pre>
 
 <li>
 <pre>
    // provider's subclass of "CipherSpi" implements "algName" with the
    // specified "padding", with pluggable mode
    <code>Cipher.</code><i>algName//padding</i>
 </pre>

 <li>
 <pre>
    // provider's subclass of "CipherSpi" implements "algName" with the
    // specified "mode" and "padding"
    <code>Cipher.</code><i>algName/mode/padding</i>
 </pre>

 </ul>

 <p>For example, a provider may supply a subclass of <code>CipherSpi</code>
 that implements <i>DES/ECB/PKCS5Padding</i>, one that implements
 <i>DES/CBC/PKCS5Padding</i>, one that implements
 <i>DES/CFB/PKCS5Padding</i>, and yet another one that implements
 <i>DES/OFB/PKCS5Padding</i>. That provider would have the following
 <code>Cipher</code> properties in its master class:<p>

 <ul>

 <li>
 <pre>
    <code>Cipher.</code><i>DES/ECB/PKCS5Padding</i>
 </pre>

 <li>
 <pre>
    <code>Cipher.</code><i>DES/CBC/PKCS5Padding</i>
 </pre>

 <li>
 <pre>
    <code>Cipher.</code><i>DES/CFB/PKCS5Padding</i>
 </pre>

 <li>
 <pre>
    <code>Cipher.</code><i>DES/OFB/PKCS5Padding</i>
 </pre>

 </ul>

 <p>Another provider may implement a class for each of the above modes
 (i.e., one class for <i>ECB</i>, one for <i>CBC</i>, one for <i>CFB</i>,
 and one for <i>OFB</i>), one class for <i>PKCS5Padding</i>,
 and a generic <i>DES</i> class that subclasses from <code>CipherSpi</code>.
 That provider would have the following
 <code>Cipher</code> properties in its master class:<p>

 <ul>

 <li>
 <pre>
    <code>Cipher.</code><i>DES</i>
 </pre>

 </ul>

 <p>The <code>getInstance</code> factory method of the <code>Cipher</code>
 engine class follows these rules in order to instantiate a provider's
 implementation of <code>CipherSpi</code> for a
 transformation of the form "<i>algorithm</i>":

 <ol>
 <li>
 Check if the provider has registered a subclass of <code>CipherSpi</code>
 for the specified "<i>algorithm</i>".
 <p>If the answer is YES, instantiate this
 class, for whose mode and padding scheme default values (as supplied by
 the provider) are used.
 <p>If the answer is NO, throw a <code>NoSuchAlgorithmException</code>
 exception.
 </ol>
  
 <p>The <code>getInstance</code> factory method of the <code>Cipher</code>
 engine class follows these rules in order to instantiate a provider's
 implementation of <code>CipherSpi</code> for a
 transformation of the form "<i>algorithm/mode/padding</i>":
  
 <ol>
 <li>
 Check if the provider has registered a subclass of <code>CipherSpi</code>
 for the specified "<i>algorithm/mode/padding</i>" transformation.
 <p>If the answer is YES, instantiate it.
 <p>If the answer is NO, go to the next step.<p>
 <li>
 Check if the provider has registered a subclass of <code>CipherSpi</code>
 for the sub-transformation "<i>algorithm/mode</i>".
 <p>If the answer is YES, instantiate it, and call
 <code>engineSetPadding(<i>padding</i>)</code> on the new instance.
 <p>If the answer is NO, go to the next step.<p>
 <li>
 Check if the provider has registered a subclass of <code>CipherSpi</code>
 for the sub-transformation "<i>algorithm//padding</i>" (note the double
 slashes).
 <p>If the answer is YES, instantiate it, and call
 <code>engineSetMode(<i>mode</i>)</code> on the new instance.
 <p>If the answer is NO, go to the next step.<p>
 <li>
 Check if the provider has registered a subclass of <code>CipherSpi</code>
 for the sub-transformation "<i>algorithm</i>".
 <p>If the answer is YES, instantiate it, and call
 <code>engineSetMode(<i>mode</i>)</code> and
 <code>engineSetPadding(<i>padding</i>)</code> on the new instance.
 <p>If the answer is NO, throw a <code>NoSuchAlgorithmException</code>
 exception.
 </ol>
<P>

<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../javax/crypto/KeyGenerator.html"><CODE>KeyGenerator</CODE></A>, 
<A HREF="../../javax/crypto/SecretKey.html"><CODE>SecretKey</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#CipherSpi()">CipherSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineDoFinal(byte[], int, int)">engineDoFinal</A></B>(byte[]&nbsp;input,
              int&nbsp;inputOffset,
              int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineDoFinal(byte[], int, int, byte[], int)">engineDoFinal</A></B>(byte[]&nbsp;input,
              int&nbsp;inputOffset,
              int&nbsp;inputLen,
              byte[]&nbsp;output,
              int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts or decrypts data in a single-part operation,
 or finishes a multiple-part operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetBlockSize()">engineGetBlockSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the block size (in bytes).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetIV()">engineGetIV</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the initialization vector (IV) in a new buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetKeySize(java.security.Key)">engineGetKeySize</A></B>(java.security.Key&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the key size of the given key object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetOutputSize(int)">engineGetOutputSize</A></B>(int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the length in bytes that an output buffer would
 need to be in order to hold the result of the next <code>update</code>
 or <code>doFinal</code> operation, given the input length
 <code>inputLen</code> (in bytes).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;java.security.AlgorithmParameters</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetParameters()">engineGetParameters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the parameters used with this cipher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineInit(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)">engineInit</A></B>(int&nbsp;opmode,
           java.security.Key&nbsp;key,
           java.security.spec.AlgorithmParameterSpec&nbsp;params,
           java.security.SecureRandom&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key, a set of
 algorithm parameters, and a source of randomness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineInit(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)">engineInit</A></B>(int&nbsp;opmode,
           java.security.Key&nbsp;key,
           java.security.AlgorithmParameters&nbsp;params,
           java.security.SecureRandom&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key, a set of
 algorithm parameters, and a source of randomness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineInit(int, java.security.Key, java.security.SecureRandom)">engineInit</A></B>(int&nbsp;opmode,
           java.security.Key&nbsp;key,
           java.security.SecureRandom&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this cipher with a key and a source
 of randomness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineSetMode(java.lang.String)">engineSetMode</A></B>(java.lang.String&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mode of this cipher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineSetPadding(java.lang.String)">engineSetPadding</A></B>(java.lang.String&nbsp;padding)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the padding mechanism of this cipher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.security.Key</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineUnwrap(byte[], java.lang.String, int)">engineUnwrap</A></B>(byte[]&nbsp;wrappedKey,
             java.lang.String&nbsp;wrappedKeyAlgorithm,
             int&nbsp;wrappedKeyType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unwrap a previously wrapped key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineUpdate(byte[], int, int)">engineUpdate</A></B>(byte[]&nbsp;input,
             int&nbsp;inputOffset,
             int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineUpdate(byte[], int, int, byte[], int)">engineUpdate</A></B>(byte[]&nbsp;input,
             int&nbsp;inputOffset,
             int&nbsp;inputLen,
             byte[]&nbsp;output,
             int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineWrap(java.security.Key)">engineWrap</A></B>(java.security.Key&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrap a key.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="CipherSpi()"><!-- --></A><H3>
CipherSpi</H3>
<PRE>
public <B>CipherSpi</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="engineSetMode(java.lang.String)"><!-- --></A><H3>
engineSetMode</H3>
<PRE>
protected abstract void <B>engineSetMode</B>(java.lang.String&nbsp;mode)
                               throws java.security.NoSuchAlgorithmException</PRE>
<DL>
<DD>Sets the mode of this cipher.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the cipher mode
<DT><B>Throws:</B>
<DD><CODE>java.security.NoSuchAlgorithmException</CODE> - if the requested cipher mode does not exist</DL>
</DD>
</DL>
<HR>

<A NAME="engineSetPadding(java.lang.String)"><!-- --></A><H3>
engineSetPadding</H3>
<PRE>
protected abstract void <B>engineSetPadding</B>(java.lang.String&nbsp;padding)
                                  throws <A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></PRE>
<DL>
<DD>Sets the padding mechanism of this cipher.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>padding</CODE> - the padding mechanism
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html">NoSuchPaddingException</A></CODE> - if the requested padding mechanism does not exist</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetBlockSize()"><!-- --></A><H3>
engineGetBlockSize</H3>
<PRE>
protected abstract int <B>engineGetBlockSize</B>()</PRE>
<DL>
<DD>Returns the block size (in bytes).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the block size (in bytes), or 0 if the underlying algorithm is not a block cipher</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetOutputSize(int)"><!-- --></A><H3>
engineGetOutputSize</H3>
<PRE>
protected abstract int <B>engineGetOutputSize</B>(int&nbsp;inputLen)</PRE>
<DL>
<DD>Returns the length in bytes that an output buffer would
 need to be in order to hold the result of the next <code>update</code>
 or <code>doFinal</code> operation, given the input length
 <code>inputLen</code> (in bytes).
 <p>
 This call takes into account any unprocessed (buffered) data from a
 previous <code>update</code> call, and padding.
 <p>
 The actual output length of the next <code>update</code> or
 <code>doFinal</code> call may be smaller than the length returned by
 this method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inputLen</CODE> - the input length (in bytes)
<DT><B>Returns:</B><DD>the required output buffer size (in bytes)</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetIV()"><!-- --></A><H3>
engineGetIV</H3>
<PRE>
protected abstract byte[] <B>engineGetIV</B>()</PRE>
<DL>
<DD>Returns the initialization vector (IV) in a new buffer. 
 <p>
 This is useful in the context of password-based encryption or
 decryption, where the IV is derived from a user-provided passphrase.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the initialization vector in a new buffer, or null if the
 underlying algorithm does not use an IV, or if the IV has not yet
 been set.</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetParameters()"><!-- --></A><H3>
engineGetParameters</H3>
<PRE>
protected abstract java.security.AlgorithmParameters <B>engineGetParameters</B>()</PRE>
<DL>
<DD>Returns the parameters used with this cipher.
 <p>
 The returned parameters may be the same that were used to initialize
 this cipher, or may contain a combination of default and random
 parameter values used by the underlying cipher implementation if this
 cipher requires algorithm parameters but was not initialized with any.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the parameters used with this cipher, or null if this cipher
 does not use any parameters.</DL>
</DD>
</DL>
<HR>

<A NAME="engineInit(int, java.security.Key, java.security.SecureRandom)"><!-- --></A><H3>
engineInit</H3>
<PRE>
protected abstract void <B>engineInit</B>(int&nbsp;opmode,
                                   java.security.Key&nbsp;key,
                                   java.security.SecureRandom&nbsp;random)
                            throws java.security.InvalidKeyException</PRE>
<DL>
<DD>Initializes this cipher with a key and a source
 of randomness.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending on
 the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters that cannot be
 derived from the given <code>key</code>, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidKeyException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#engineGetParameters()">engineGetParameters</a> or
 <a href = "#engineGetIV()">engineGetIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from <code>random</code>.
 
 <p>Note that when a Cipher object is initialized, it loses all 
 previously-acquired state. In other words, initializing a Cipher is 
 equivalent to creating a new instance of that Cipher and initializing 
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of
 the following:
 <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
 <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>random</CODE> - the source of randomness
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for
 initializing this cipher, or if this cipher is being initialized for
 decryption and requires algorithm parameters that cannot be
 determined from the given key.</DL>
</DD>
</DL>
<HR>

<A NAME="engineInit(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)"><!-- --></A><H3>
engineInit</H3>
<PRE>
protected abstract void <B>engineInit</B>(int&nbsp;opmode,
                                   java.security.Key&nbsp;key,
                                   java.security.spec.AlgorithmParameterSpec&nbsp;params,
                                   java.security.SecureRandom&nbsp;random)
                            throws java.security.InvalidKeyException,
                                   java.security.InvalidAlgorithmParameterException</PRE>
<DL>
<DD>Initializes this cipher with a key, a set of
 algorithm parameters, and a source of randomness.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending on
 the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters and
  <code>params</code> is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidAlgorithmParameterException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#engineGetParameters()">engineGetParameters</a> or
 <a href = "#engineGetIV()">engineGetIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from <code>random</code>.
 <p>
 Note that when a Cipher object is initialized, it loses all 
 previously-acquired state. In other words, initializing a Cipher is 
 equivalent to creating a new instance of that Cipher and initializing 
 it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the following: 
 <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,
 <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>params</CODE> - the algorithm parameters<DD><CODE>random</CODE> - the source of randomness
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for initializing this cipher
<DD><CODE>java.security.InvalidAlgorithmParameterException</CODE> - if the given algorithm parameters are inappropriate
 for this cipher, or if this cipher is being initialized for decryption and requires
 algorithm parameters and <code>params</code> is null.</DL>
</DD>
</DL>
<HR>

<A NAME="engineInit(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)"><!-- --></A><H3>
engineInit</H3>
<PRE>
protected abstract void <B>engineInit</B>(int&nbsp;opmode,
                                   java.security.Key&nbsp;key,
                                   java.security.AlgorithmParameters&nbsp;params,
                                   java.security.SecureRandom&nbsp;random)
                            throws java.security.InvalidKeyException,
                                   java.security.InvalidAlgorithmParameterException</PRE>
<DL>
<DD>Initializes this cipher with a key, a set of
 algorithm parameters, and a source of randomness.
 <p>
 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending on
 the value of <code>opmode</code>.
 <p>
 If this cipher requires any algorithm parameters and
 <code>params</code> is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 <code>InvalidAlgorithmParameterException</code> if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 <a href = "#engineGetParameters()">engineGetParameters</a> or
 <a href = "#engineGetIV()">engineGetIV</a> (if the parameter is an IV).
 <p>
 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from <code>random</code>.
 <p>
 Note that when a Cipher object is initialized, it loses all 
 previously-acquired state. In other words, initializing a Cipher is 
 equivalent to creating a new instance of that Cipher and initializing it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opmode</CODE> - the operation mode of this cipher (this is one of the following: 
 <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>
 or <code>UNWRAP_MODE</code>)<DD><CODE>key</CODE> - the encryption key<DD><CODE>params</CODE> - the algorithm parameters<DD><CODE>random</CODE> - the source of randomness
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if the given key is inappropriate for initializing this cipher
<DD><CODE>java.security.InvalidAlgorithmParameterException</CODE> - if the given algorithm parameters are inappropriate
 for this cipher, or if this cipher is being initialized for decryption and requires
 algorithm parameters and <code>params</code> is null.</DL>
</DD>
</DL>
<HR>

<A NAME="engineUpdate(byte[], int, int)"><!-- --></A><H3>
engineUpdate</H3>
<PRE>
protected abstract byte[] <B>engineUpdate</B>(byte[]&nbsp;input,
                                       int&nbsp;inputOffset,
                                       int&nbsp;inputLen)</PRE>
<DL>
<DD>Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, are processed,
 and the result is stored in a new buffer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length
<DT><B>Returns:</B><DD>the new buffer with the result, or null if the underlying cipher is a
 block cipher and the input data is too short to result in a new block.</DL>
</DD>
</DL>
<HR>

<A NAME="engineUpdate(byte[], int, int, byte[], int)"><!-- --></A><H3>
engineUpdate</H3>
<PRE>
protected abstract int <B>engineUpdate</B>(byte[]&nbsp;input,
                                    int&nbsp;inputOffset,
                                    int&nbsp;inputLen,
                                    byte[]&nbsp;output,
                                    int&nbsp;outputOffset)
                             throws <A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></PRE>
<DL>
<DD>Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, are processed,
 and the result is stored in the <code>output</code> buffer, starting at
 <code>outputOffset</code> inclusive.
 <p>
 If the <code>output</code> buffer is too small to hold the result,
 a <code>ShortBufferException</code> is thrown.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length<DD><CODE>output</CODE> - the buffer for the result<DD><CODE>outputOffset</CODE> - the offset in <code>output</code> where the result is stored
<DT><B>Returns:</B><DD>the number of bytes stored in <code>output</code>
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></CODE> - if the given output buffer is too small to hold the result</DL>
</DD>
</DL>
<HR>

<A NAME="engineDoFinal(byte[], int, int)"><!-- --></A><H3>
engineDoFinal</H3>
<PRE>
protected abstract byte[] <B>engineDoFinal</B>(byte[]&nbsp;input,
                                        int&nbsp;inputOffset,
                                        int&nbsp;inputLen)
                                 throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                                        <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.
 The data is encrypted or decrypted, depending on how this cipher was initialized.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, and any input
 bytes that may have been buffered during a previous <code>update</code>
 operation, are processed, with padding (if requested) being applied.
 The result is stored in a new buffer.
 <p>
 A call to this method resets this cipher object to the state 
 it was in when previously initialized via a call to <code>engineInit</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>engineInit</code>) more data.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length
<DT><B>Returns:</B><DD>the new buffer with the result
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher, no padding has been requested
 (only in encryption mode), and the total input length of the data processed by this cipher is not a
 multiple of block size
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode, and (un)padding has been requested,
 but the decrypted data is not bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="engineDoFinal(byte[], int, int, byte[], int)"><!-- --></A><H3>
engineDoFinal</H3>
<PRE>
protected abstract int <B>engineDoFinal</B>(byte[]&nbsp;input,
                                     int&nbsp;inputOffset,
                                     int&nbsp;inputLen,
                                     byte[]&nbsp;output,
                                     int&nbsp;outputOffset)
                              throws <A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A>,
                                     <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                                     <A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></PRE>
<DL>
<DD>Encrypts or decrypts data in a single-part operation,
 or finishes a multiple-part operation.
 The data is encrypted or decrypted, depending on how this cipher was
 initialized.
 <p>
 The first <code>inputLen</code> bytes in the <code>input</code>
 buffer, starting at <code>inputOffset</code> inclusive, and any input
 bytes that may have been buffered during a previous <code>update</code>
 operation, are processed, with padding (if requested) being applied.
 The result is stored in the <code>output</code> buffer, starting at
 <code>outputOffset</code> inclusive.
 <p>
 If the <code>output</code> buffer is too small to hold the result,
 a <code>ShortBufferException</code> is thrown.
 <p>
 A call to this method resets this cipher object to the state 
 it was in when previously initialized via a call to
 <code>engineInit</code>.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 <code>engineInit</code>) more data.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the input buffer<DD><CODE>inputOffset</CODE> - the offset in <code>input</code> where the input starts<DD><CODE>inputLen</CODE> - the input length<DD><CODE>output</CODE> - the buffer for the result<DD><CODE>outputOffset</CODE> - the offset in <code>output</code> where the result is stored
<DT><B>Returns:</B><DD>the number of bytes stored in <code>output</code>
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher, no padding has been
 requested (only in encryption mode), and the total input length of the data processed by this
 cipher is not a multiple of block size
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html">ShortBufferException</A></CODE> - if the given output buffer is too small to hold the result
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html">BadPaddingException</A></CODE> - if this cipher is in decryption mode, and (un)padding has been requested,
 but the decrypted data is not bounded by the appropriate padding bytes</DL>
</DD>
</DL>
<HR>

<A NAME="engineWrap(java.security.Key)"><!-- --></A><H3>
engineWrap</H3>
<PRE>
protected byte[] <B>engineWrap</B>(java.security.Key&nbsp;key)
                     throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A>,
                            java.security.InvalidKeyException</PRE>
<DL>
<DD>Wrap a key.
 <p>
 This concrete method has been added to this previously-defined
 abstract class. (For backwards compatibility, it cannot be abstract.)
 It may be overridden by a provider to wrap a key.
 Such an override is expected to throw an IllegalBlockSizeException or
 InvalidKeyException (under the specified circumstances),
 if the given key cannot be wrapped.
 If this method is not overridden, it always throws an
 UnsupportedOperationException.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to be wrapped.
<DT><B>Returns:</B><DD>the wrapped key.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html">IllegalBlockSizeException</A></CODE> - if this cipher is a block cipher, no padding has been requested,
 and the length of the encoding of the key to be wrapped is not a multiple of the block size.
<DD><CODE>java.security.InvalidKeyException</CODE> - if it is impossible or unsafe to wrap the key with this cipher (e.g.,
 a hardware protected key is being passed to a software-only cipher).</DL>
</DD>
</DL>
<HR>

<A NAME="engineUnwrap(byte[], java.lang.String, int)"><!-- --></A><H3>
engineUnwrap</H3>
<PRE>
protected java.security.Key <B>engineUnwrap</B>(byte[]&nbsp;wrappedKey,
                                         java.lang.String&nbsp;wrappedKeyAlgorithm,
                                         int&nbsp;wrappedKeyType)
                                  throws java.security.InvalidKeyException,
                                         java.security.NoSuchAlgorithmException</PRE>
<DL>
<DD>Unwrap a previously wrapped key.

 <p>This concrete method has been added to this previously-defined
 abstract class. (For backwards compatibility, it cannot be abstract.)
 It may be overridden by a provider to unwrap a previously wrapped key.
 Such an override is expected to throw an InvalidKeyException if
 the given wrapped key cannot be unwrapped.
 If this method is not overridden, it always throws an
 UnsupportedOperationException.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>wrappedKey</CODE> - the key to be unwrapped.<DD><CODE>wrappedKeyAlgorithm</CODE> - the algorithm associated with the wrapped key.<DD><CODE>wrappedKeyType</CODE> - the type of the wrapped key. This is one of <code>SECRET_KEY</code>,
 <code>PRIVATE_KEY</code>, or <code>PUBLIC_KEY</code>.
<DT><B>Returns:</B><DD>the unwrapped key.
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if <code>wrappedKey</code> does not represent a wrapped key,
 or if the algorithm associated with the wrapped key is different from <code>wrappedKeyAlgorithm</code> 
 and/or its key type is different from <code>wrappedKeyType</code>.
<DD><CODE>java.security.NoSuchAlgorithmException</CODE> - - if no installed providers can create keys for the
 <code>wrappedKeyAlgorithm</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetKeySize(java.security.Key)"><!-- --></A><H3>
engineGetKeySize</H3>
<PRE>
protected int <B>engineGetKeySize</B>(java.security.Key&nbsp;key)
                        throws java.security.InvalidKeyException</PRE>
<DL>
<DD>Returns the key size of the given key object.
 <p>
 This concrete method has been added to this previously-defined
 abstract class. It throws an <code>UnsupportedOperationException</code>
 if it is not overridden by the provider.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key object.
<DT><B>Returns:</B><DD>the key size of the given key object.
<DT><B>Throws:</B>
<DD><CODE>java.security.InvalidKeyException</CODE> - if <code>key</code> is invalid.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<A HREF="#main"><FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../serialized-form.html"><FONT CLASS="NavBarFont1"><B>Serialized</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
For the latest news and information visit<BR><A HREF="http://www.gnu.org/software/gnu-crypto">The GNU Crypto project</A></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/crypto/CipherOutputStream.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javax/crypto/EncryptedPrivateKeyInfo.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="CipherSpi.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
Copyright &copy; 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
</BODY>
</HTML>
